{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///virtualized-list.min.js","webpack:///webpack/bootstrap 94a7992885f4de7c0c1a","webpack:///./src/VirtualList/index.js","webpack:///./src/InfiniteVirtualList/index.js","webpack:///./src/VirtualList/SizeAndPositionManager.js","webpack:///./~/morphdom/dist/morphdom-esm.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","_classCallCheck","instance","Constructor","TypeError","__WEBPACK_IMPORTED_MODULE_0_morphdom__","__WEBPACK_IMPORTED_MODULE_1__SizeAndPositionManager__","VirtualizedList","STYLE_INNER","STYLE_CONTENT","container","options","_this","getRowHeight","_ref","index","rowHeight","Array","isArray","state","_initializeSizeAndPositionManager","rowCount","render","bind","handleScroll","componentDidMount","_this2","_options","onMount","initialScrollTop","initialIndex","height","offset","getRowOffset","inner","document","createElement","content","setAttribute","appendChild","setState","scrollTop","addEventListener","count","_sizeAndPositionManager","itemCount","itemSizeGetter","estimatedItemSize","estimatedRowHeight","_this3","arguments","length","undefined","callback","assign","requestAnimationFrame","resize","e","onScroll","getSizeAndPositionForIndex","scrollToIndex","alignment","getUpdatedOffsetForIndex","align","containerSize","targetIndex","setRowCount","onRowsRendered","renderedRows","destroy","removeEventListener","innerHTML","_options2","overscanCount","renderRow","_state","_state$offset","_sizeAndPositionManag2","getVisibleRange","start","stop","fragment","createDocumentFragment","style","getTotalSize","top","childrenOnly","getNodeKey","node","id","startIndex","stopIndex","__WEBPACK_IMPORTED_MODULE_0__VirtualList__","__WEBPACK_IMPORTED_MODULE_1__InfiniteVirtualList__","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","create","constructor","writable","setPrototypeOf","__proto__","isRangeVisible","_ref2","lastRenderedStartIndex","lastRenderedStopIndex","getUnloadedRanges","_ref3","isRowLoaded","minimumBatchSize","unloadedRanges","rangeStartIndex","rangeStopIndex","push","potentialStopIndex","Math","min","max","firstUnloadedRange","InfiniteVirtualList","_VirtualList","apply","loadMoreRows","_options$minimumBatch","_options$rowCount","_options$threshold","threshold","forEach","unloadedRange","promise","then","SizeAndPositionManager","ALIGN_START","ALIGN_CENTER","ALIGN_END","_itemSizeGetter","_itemCount","_estimatedItemSize","_itemSizeAndPositionData","_lastMeasuredIndex","getLastMeasuredIndex","Error","lastMeasuredSizeAndPosition","getSizeAndPositionOfLastMeasuredItem","size","isNaN","_ref2$align","datum","maxOffset","minOffset","idealOffset","totalSize","_findNearestItem","resetItem","_binarySearch","_ref4","low","high","middle","currentOffset","floor","_exponentialSearch","_ref5","interval","lastMeasuredIndex","morphAttrs","fromNode","toNode","attr","attrName","attrNamespaceURI","attrValue","attrs","attributes","namespaceURI","localName","getAttributeNS","setAttributeNS","getAttribute","specified","hasAttributeNS","removeAttributeNS","hasAttribute","removeAttribute","toElement","str","range","doc","createRange","createContextualFragment","childNodes","compareNodeNames","fromEl","toEl","fromNodeName","nodeName","toNodeName","actualize","charCodeAt","toUpperCase","createElementNS","NS_XHTML","moveChildren","curChild","firstChild","nextChild","nextSibling","syncBooleanAttrProp","noop","defaultGetNodeKey","morphdomFactory","addKeyedRemoval","key","keyedRemovalList","walkDiscardedChildNodes","skipKeyedNodes","nodeType","ELEMENT_NODE","onNodeDiscarded","removeNode","parentNode","onBeforeNodeDiscarded","removeChild","indexTree","fromNodesLookup","handleNodeAdded","el","onNodeAdded","unmatchedFromEl","replaceChild","morphChildren","curFromNodeKey","toElKey","isSameNode","onBeforeElUpdated","onElUpdated","onBeforeElChildrenUpdated","curToNodeKey","fromNextSibling","toNextSibling","matchingFromEl","curToNodeChild","curFromNodeChild","outer","curFromNodeType","isCompatible","insertBefore","TEXT_NODE","COMMENT_NODE","nodeValue","onBeforeNodeAddedResult","onBeforeNodeAdded","ownerDocument","specialElHandler","specialElHandlers","toNodeHtml","morphedNode","morphedNodeType","toNodeType","len","elToRemove","OPTION","parentName","selected","selectedIndex","INPUT","TEXTAREA","newValue","oldValue","placeholder","SELECT","optgroup","morphdom"],"mappings":"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","file":"virtualized-list.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"VirtualizedList\"] = factory();\n\telse\n\t\troot[\"VirtualizedList\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"VirtualizedList\"] = factory();\n\telse\n\t\troot[\"VirtualizedList\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 5);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_morphdom__ = __webpack_require__(4);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__SizeAndPositionManager__ = __webpack_require__(3);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return VirtualizedList; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n\n\n\nvar STYLE_INNER = 'position:relative; overflow:hidden; width:100%; min-height:100%; will-change: transform;';\nvar STYLE_CONTENT = 'position:absolute; top:0; left:0; height:100%; width:100%; overflow:visible;';\n\nvar VirtualizedList = function () {\n  function VirtualizedList(container, options) {\n    var _this = this;\n\n    _classCallCheck(this, VirtualizedList);\n\n    this.getRowHeight = function (_ref) {\n      var index = _ref.index;\n      var rowHeight = _this.options.rowHeight;\n\n\n      if (typeof rowHeight === 'function') {\n        return rowHeight(index);\n      }\n\n      return Array.isArray(rowHeight) ? rowHeight[index] : rowHeight;\n    };\n\n    this.container = container;\n    this.options = options;\n\n    // Initialization\n    this.state = {};\n    this._initializeSizeAndPositionManager(options.rowCount);\n\n    // Binding\n    this.render = this.render.bind(this);\n    this.handleScroll = this.handleScroll.bind(this);\n\n    // Lifecycle Methods\n    this.componentDidMount();\n  }\n\n  VirtualizedList.prototype.componentDidMount = function componentDidMount() {\n    var _this2 = this;\n\n    var _options = this.options,\n        onMount = _options.onMount,\n        initialScrollTop = _options.initialScrollTop,\n        initialIndex = _options.initialIndex,\n        height = _options.height;\n\n    var offset = initialScrollTop || initialIndex != null && this.getRowOffset(initialIndex) || 0;\n    var inner = this.inner = document.createElement('div');\n    var content = this.content = document.createElement('div');\n\n    inner.setAttribute('style', STYLE_INNER);\n    content.setAttribute('style', STYLE_CONTENT);\n    inner.appendChild(content);\n    this.container.appendChild(inner);\n\n    this.setState({\n      offset: offset,\n      height: height\n    }, function () {\n      if (offset) {\n        _this2.container.scrollTop = offset;\n      }\n\n      // Add event listeners\n      _this2.container.addEventListener('scroll', _this2.handleScroll);\n\n      if (typeof onMount === 'function') {\n        onMount();\n      }\n    });\n  };\n\n  VirtualizedList.prototype._initializeSizeAndPositionManager = function _initializeSizeAndPositionManager(count) {\n    this._sizeAndPositionManager = new __WEBPACK_IMPORTED_MODULE_1__SizeAndPositionManager__[\"a\" /* default */]({\n      itemCount: count,\n      itemSizeGetter: this.getRowHeight,\n      estimatedItemSize: this.options.estimatedRowHeight || 100\n    });\n  };\n\n  VirtualizedList.prototype.setState = function setState() {\n    var _this3 = this;\n\n    var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var callback = arguments[1];\n\n    this.state = Object.assign(this.state, state);\n\n    requestAnimationFrame(function () {\n      _this3.render();\n\n      if (typeof callback === 'function') {\n        callback();\n      }\n    });\n  };\n\n  VirtualizedList.prototype.resize = function resize(height, callback) {\n    this.setState({\n      height: height\n    }, callback);\n  };\n\n  VirtualizedList.prototype.handleScroll = function handleScroll(e) {\n    var onScroll = this.options.onScroll;\n\n    var offset = this.container.scrollTop;\n\n    this.setState({ offset: offset });\n\n    if (typeof onScroll === 'function') {\n      onScroll(offset, e);\n    }\n  };\n\n  VirtualizedList.prototype.getRowOffset = function getRowOffset(index) {\n    var _sizeAndPositionManag = this._sizeAndPositionManager.getSizeAndPositionForIndex(index),\n        offset = _sizeAndPositionManag.offset;\n\n    return offset;\n  };\n\n  VirtualizedList.prototype.scrollToIndex = function scrollToIndex(index, alignment) {\n    var height = this.state.height;\n\n    var offset = this._sizeAndPositionManager.getUpdatedOffsetForIndex({\n      align: alignment,\n      containerSize: height,\n      targetIndex: index\n    });\n\n    this.container.scrollTop = offset;\n  };\n\n  VirtualizedList.prototype.setRowCount = function setRowCount(count) {\n    this._initializeSizeAndPositionManager(count);\n    this.render();\n  };\n\n  VirtualizedList.prototype.onRowsRendered = function onRowsRendered(renderedRows) {\n    var onRowsRendered = this.options.onRowsRendered;\n\n\n    if (typeof onRowsRendered === 'function') {\n      onRowsRendered(renderedRows);\n    }\n  };\n\n  VirtualizedList.prototype.destroy = function destroy() {\n    this.container.removeEventListener('scroll', this.handleScroll);\n    this.container.innerHTML = '';\n  };\n\n  VirtualizedList.prototype.render = function render() {\n    var _options2 = this.options,\n        overscanCount = _options2.overscanCount,\n        renderRow = _options2.renderRow;\n    var _state = this.state,\n        height = _state.height,\n        _state$offset = _state.offset,\n        offset = _state$offset === undefined ? 0 : _state$offset;\n\n    var _sizeAndPositionManag2 = this._sizeAndPositionManager.getVisibleRange({\n      containerSize: height,\n      offset: offset,\n      overscanCount: overscanCount\n    }),\n        start = _sizeAndPositionManag2.start,\n        stop = _sizeAndPositionManag2.stop;\n\n    var fragment = document.createDocumentFragment();\n\n    for (var index = start; index <= stop; index++) {\n      fragment.appendChild(renderRow(index));\n    }\n\n    this.inner.style.height = this._sizeAndPositionManager.getTotalSize() + 'px';\n    this.content.style.top = this.getRowOffset(start) + 'px';\n\n    __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_0_morphdom__[\"a\" /* default */])(this.content, fragment, {\n      childrenOnly: true,\n      getNodeKey: function getNodeKey(node) {\n        return node.id;\n      }\n    });\n\n    this.onRowsRendered({\n      startIndex: start,\n      stopIndex: stop\n    });\n  };\n\n  return VirtualizedList;\n}();\n\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__VirtualList__ = __webpack_require__(0);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return __WEBPACK_IMPORTED_MODULE_0__VirtualList__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__InfiniteVirtualList__ = __webpack_require__(2);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"InfiniteVirtualList\", function() { return __WEBPACK_IMPORTED_MODULE_1__InfiniteVirtualList__[\"a\"]; });\n\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__VirtualList__ = __webpack_require__(0);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return InfiniteVirtualList; });\n/* unused harmony export isRangeVisible */\n/* unused harmony export getUnloadedRanges */\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\n\n\nvar InfiniteVirtualList = function (_VirtualList) {\n  _inherits(InfiniteVirtualList, _VirtualList);\n\n  function InfiniteVirtualList() {\n    _classCallCheck(this, InfiniteVirtualList);\n\n    return _possibleConstructorReturn(this, _VirtualList.apply(this, arguments));\n  }\n\n  InfiniteVirtualList.prototype.onRowsRendered = function onRowsRendered(_ref) {\n    var _this2 = this;\n\n    var startIndex = _ref.startIndex,\n        stopIndex = _ref.stopIndex;\n    var _options = this.options,\n        isRowLoaded = _options.isRowLoaded,\n        loadMoreRows = _options.loadMoreRows,\n        _options$minimumBatch = _options.minimumBatchSize,\n        minimumBatchSize = _options$minimumBatch === undefined ? 10 : _options$minimumBatch,\n        _options$rowCount = _options.rowCount,\n        rowCount = _options$rowCount === undefined ? 0 : _options$rowCount,\n        _options$threshold = _options.threshold,\n        threshold = _options$threshold === undefined ? 15 : _options$threshold;\n\n\n    var unloadedRanges = getUnloadedRanges({\n      isRowLoaded: isRowLoaded,\n      minimumBatchSize: minimumBatchSize,\n      rowCount: rowCount,\n      startIndex: Math.max(0, startIndex - threshold),\n      stopIndex: Math.min(rowCount - 1, stopIndex + threshold)\n    });\n\n    unloadedRanges.forEach(function (unloadedRange) {\n      var promise = loadMoreRows(unloadedRange);\n\n      if (promise) {\n        promise.then(function () {\n          // Refresh the visible rows if any of them have just been loaded.\n          // Otherwise they will remain in their unloaded visual state.\n          if (isRangeVisible({\n            lastRenderedStartIndex: startIndex,\n            lastRenderedStopIndex: stopIndex,\n            startIndex: unloadedRange.startIndex,\n            stopIndex: unloadedRange.stopIndex\n          })) {\n            // Force update\n            _this2.render();\n          }\n        });\n      }\n    });\n  };\n\n  return InfiniteVirtualList;\n}(__WEBPACK_IMPORTED_MODULE_0__VirtualList__[\"a\" /* default */]);\n\n/**\n * Determines if the specified start/stop range is visible based on the most recently rendered range.\n */\n\n\n\nfunction isRangeVisible(_ref2) {\n  var lastRenderedStartIndex = _ref2.lastRenderedStartIndex,\n      lastRenderedStopIndex = _ref2.lastRenderedStopIndex,\n      startIndex = _ref2.startIndex,\n      stopIndex = _ref2.stopIndex;\n\n  return !(startIndex > lastRenderedStopIndex || stopIndex < lastRenderedStartIndex);\n}\n\n/**\n * Returns all of the ranges within a larger range that contain unloaded rows.\n */\nfunction getUnloadedRanges(_ref3) {\n  var isRowLoaded = _ref3.isRowLoaded,\n      minimumBatchSize = _ref3.minimumBatchSize,\n      rowCount = _ref3.rowCount,\n      startIndex = _ref3.startIndex,\n      stopIndex = _ref3.stopIndex;\n\n  var unloadedRanges = [];\n  var rangeStartIndex = null;\n  var rangeStopIndex = null;\n\n  for (var index = startIndex; index <= stopIndex; index++) {\n    var loaded = isRowLoaded(index);\n\n    if (!loaded) {\n      rangeStopIndex = index;\n      if (rangeStartIndex === null) {\n        rangeStartIndex = index;\n      }\n    } else if (rangeStopIndex !== null) {\n      unloadedRanges.push({\n        startIndex: rangeStartIndex,\n        stopIndex: rangeStopIndex\n      });\n\n      rangeStartIndex = rangeStopIndex = null;\n    }\n  }\n\n  // If :rangeStopIndex is not null it means we haven't ran out of unloaded rows.\n  // Scan forward to try filling our :minimumBatchSize.\n  if (rangeStopIndex !== null) {\n    var potentialStopIndex = Math.min(Math.max(rangeStopIndex, rangeStartIndex + minimumBatchSize - 1), rowCount - 1);\n\n    for (var _index = rangeStopIndex + 1; _index <= potentialStopIndex; _index++) {\n      if (!isRowLoaded({ index: _index })) {\n        rangeStopIndex = _index;\n      } else {\n        break;\n      }\n    }\n\n    unloadedRanges.push({\n      startIndex: rangeStartIndex,\n      stopIndex: rangeStopIndex\n    });\n  }\n\n  // Check to see if our first range ended prematurely.\n  // In this case we should scan backwards to try filling our :minimumBatchSize.\n  if (unloadedRanges.length) {\n    var firstUnloadedRange = unloadedRanges[0];\n\n    while (firstUnloadedRange.stopIndex - firstUnloadedRange.startIndex + 1 < minimumBatchSize && firstUnloadedRange.startIndex > 0) {\n      var _index2 = firstUnloadedRange.startIndex - 1;\n\n      if (!isRowLoaded({ index: _index2 })) {\n        firstUnloadedRange.startIndex = _index2;\n      } else {\n        break;\n      }\n    }\n  }\n\n  return unloadedRanges;\n}\n\n/***/ }),\n/* 3 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* unused harmony export ALIGN_START */\n/* unused harmony export ALIGN_CENTER */\n/* unused harmony export ALIGN_END */\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return SizeAndPositionManager; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/* Forked from react-virtualized 💖 */\nvar ALIGN_START = 'start';\nvar ALIGN_CENTER = 'center';\nvar ALIGN_END = 'end';\n\nvar SizeAndPositionManager = function () {\n  function SizeAndPositionManager(_ref) {\n    var itemCount = _ref.itemCount,\n        itemSizeGetter = _ref.itemSizeGetter,\n        estimatedItemSize = _ref.estimatedItemSize;\n\n    _classCallCheck(this, SizeAndPositionManager);\n\n    this._itemSizeGetter = itemSizeGetter;\n    this._itemCount = itemCount;\n    this._estimatedItemSize = estimatedItemSize;\n\n    // Cache of size and position data for items, mapped by item index.\n    this._itemSizeAndPositionData = {};\n\n    // Measurements for items up to this index can be trusted; items afterward should be estimated.\n    this._lastMeasuredIndex = -1;\n  }\n\n  SizeAndPositionManager.prototype.getLastMeasuredIndex = function getLastMeasuredIndex() {\n    return this._lastMeasuredIndex;\n  };\n\n  /**\n   * This method returns the size and position for the item at the specified index.\n   * It just-in-time calculates (or used cached values) for items leading up to the index.\n   */\n\n\n  SizeAndPositionManager.prototype.getSizeAndPositionForIndex = function getSizeAndPositionForIndex(index) {\n    if (index < 0 || index >= this._itemCount) {\n      throw Error('Requested index ' + index + ' is outside of range 0..' + this._itemCount);\n    }\n\n    if (index > this._lastMeasuredIndex) {\n      var lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\n      var offset = lastMeasuredSizeAndPosition.offset + lastMeasuredSizeAndPosition.size;\n\n      for (var i = this._lastMeasuredIndex + 1; i <= index; i++) {\n        var size = this._itemSizeGetter({ index: i });\n\n        if (size == null || isNaN(size)) {\n          throw Error('Invalid size returned for index ' + i + ' of value ' + size);\n        }\n\n        this._itemSizeAndPositionData[i] = {\n          offset: offset,\n          size: size\n        };\n\n        offset += size;\n      }\n\n      this._lastMeasuredIndex = index;\n    }\n\n    return this._itemSizeAndPositionData[index];\n  };\n\n  SizeAndPositionManager.prototype.getSizeAndPositionOfLastMeasuredItem = function getSizeAndPositionOfLastMeasuredItem() {\n    return this._lastMeasuredIndex >= 0 ? this._itemSizeAndPositionData[this._lastMeasuredIndex] : { offset: 0, size: 0 };\n  };\n\n  /**\n  * Total size of all items being measured.\n  * This value will be completedly estimated initially.\n  * As items as measured the estimate will be updated.\n  */\n\n\n  SizeAndPositionManager.prototype.getTotalSize = function getTotalSize() {\n    var lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\n\n    return lastMeasuredSizeAndPosition.offset + lastMeasuredSizeAndPosition.size + (this._itemCount - this._lastMeasuredIndex - 1) * this._estimatedItemSize;\n  };\n\n  /**\n   * Determines a new offset that ensures a certain item is visible, given the alignment.\n   *\n   * @param align Desired alignment within container; one of \"start\" (default), \"center\", or \"end\"\n   * @param containerSize Size (width or height) of the container viewport\n   * @return Offset to use to ensure the specified item is visible\n   */\n\n\n  SizeAndPositionManager.prototype.getUpdatedOffsetForIndex = function getUpdatedOffsetForIndex(_ref2) {\n    var _ref2$align = _ref2.align,\n        align = _ref2$align === undefined ? ALIGN_START : _ref2$align,\n        containerSize = _ref2.containerSize,\n        targetIndex = _ref2.targetIndex;\n\n    if (containerSize <= 0) {\n      return 0;\n    }\n\n    var datum = this.getSizeAndPositionForIndex(targetIndex);\n    var maxOffset = datum.offset;\n    var minOffset = maxOffset - containerSize + datum.size;\n\n    var idealOffset = void 0;\n\n    switch (align) {\n      case ALIGN_END:\n        idealOffset = minOffset;\n        break;\n      case ALIGN_CENTER:\n        idealOffset = maxOffset - (containerSize - datum.size) / 2;\n        break;\n      default:\n        idealOffset = maxOffset;\n        break;\n    }\n\n    var totalSize = this.getTotalSize();\n\n    return Math.max(0, Math.min(totalSize - containerSize, idealOffset));\n  };\n\n  SizeAndPositionManager.prototype.getVisibleRange = function getVisibleRange(_ref3) {\n    var containerSize = _ref3.containerSize,\n        offset = _ref3.offset,\n        overscanCount = _ref3.overscanCount;\n\n    var totalSize = this.getTotalSize();\n\n    if (totalSize === 0) {\n      return {};\n    }\n\n    var maxOffset = offset + containerSize;\n    var start = this._findNearestItem(offset);\n    var stop = start;\n\n    var datum = this.getSizeAndPositionForIndex(start);\n    offset = datum.offset + datum.size;\n\n    while (offset < maxOffset && stop < this._itemCount - 1) {\n      stop++;\n      offset += this.getSizeAndPositionForIndex(stop).size;\n    }\n\n    if (overscanCount) {\n      start = Math.max(0, start - overscanCount);\n      stop = Math.min(stop + overscanCount, this._itemCount);\n    }\n\n    return {\n      start: start,\n      stop: stop\n    };\n  };\n\n  /**\n   * Clear all cached values for items after the specified index.\n   * This method should be called for any item that has changed its size.\n   * It will not immediately perform any calculations; they'll be performed the next time getSizeAndPositionForIndex() is called.\n   */\n\n\n  SizeAndPositionManager.prototype.resetItem = function resetItem(index) {\n    this._lastMeasuredIndex = Math.min(this._lastMeasuredIndex, index - 1);\n  };\n\n  SizeAndPositionManager.prototype._binarySearch = function _binarySearch(_ref4) {\n    var low = _ref4.low,\n        high = _ref4.high,\n        offset = _ref4.offset;\n\n    var middle = void 0;\n    var currentOffset = void 0;\n\n    while (low <= high) {\n      middle = low + Math.floor((high - low) / 2);\n      currentOffset = this.getSizeAndPositionForIndex(middle).offset;\n\n      if (currentOffset === offset) {\n        return middle;\n      } else if (currentOffset < offset) {\n        low = middle + 1;\n      } else if (currentOffset > offset) {\n        high = middle - 1;\n      }\n    }\n\n    if (low > 0) {\n      return low - 1;\n    }\n  };\n\n  SizeAndPositionManager.prototype._exponentialSearch = function _exponentialSearch(_ref5) {\n    var index = _ref5.index,\n        offset = _ref5.offset;\n\n    var interval = 1;\n\n    while (index < this._itemCount && this.getSizeAndPositionForIndex(index).offset < offset) {\n      index += interval;\n      interval *= 2;\n    }\n\n    return this._binarySearch({\n      high: Math.min(index, this._itemCount - 1),\n      low: Math.floor(index / 2),\n      offset: offset\n    });\n  };\n\n  /**\n   * Searches for the item (index) nearest the specified offset.\n   *\n   * If no exact match is found the next lowest item index will be returned.\n   * This allows partially visible items (with offsets just before/above the fold) to be visible.\n   */\n\n\n  SizeAndPositionManager.prototype._findNearestItem = function _findNearestItem(offset) {\n    if (isNaN(offset)) {\n      throw Error('Invalid offset ' + offset + ' specified');\n    }\n\n    // Our search algorithms find the nearest match at or below the specified offset.\n    // So make sure the offset is at least 0 or no match will be found.\n    offset = Math.max(0, offset);\n\n    var lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\n    var lastMeasuredIndex = Math.max(0, this._lastMeasuredIndex);\n\n    if (lastMeasuredSizeAndPosition.offset >= offset) {\n      // If we've already measured items within this range just use a binary search as it's faster.\n      return this._binarySearch({\n        high: lastMeasuredIndex,\n        low: 0,\n        offset: offset\n      });\n    } else {\n      // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n      // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n      // The overall complexity for this approach is O(log n).\n      return this._exponentialSearch({\n        index: lastMeasuredIndex,\n        offset: offset\n      });\n    }\n  };\n\n  return SizeAndPositionManager;\n}();\n\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nfunction morphAttrs(fromNode, toNode) {\n    var attrs = toNode.attributes;\n    var i;\n    var attr;\n    var attrName;\n    var attrNamespaceURI;\n    var attrValue;\n    var fromValue;\n\n    // update attributes on original DOM element\n    for (i = attrs.length - 1; i >= 0; --i) {\n        attr = attrs[i];\n        attrName = attr.name;\n        attrNamespaceURI = attr.namespaceURI;\n        attrValue = attr.value;\n\n        if (attrNamespaceURI) {\n            attrName = attr.localName || attrName;\n            fromValue = fromNode.getAttributeNS(attrNamespaceURI, attrName);\n\n            if (fromValue !== attrValue) {\n                fromNode.setAttributeNS(attrNamespaceURI, attrName, attrValue);\n            }\n        } else {\n            fromValue = fromNode.getAttribute(attrName);\n\n            if (fromValue !== attrValue) {\n                fromNode.setAttribute(attrName, attrValue);\n            }\n        }\n    }\n\n    // Remove any extra attributes found on the original DOM element that\n    // weren't found on the target element.\n    attrs = fromNode.attributes;\n\n    for (i = attrs.length - 1; i >= 0; --i) {\n        attr = attrs[i];\n        if (attr.specified !== false) {\n            attrName = attr.name;\n            attrNamespaceURI = attr.namespaceURI;\n\n            if (attrNamespaceURI) {\n                attrName = attr.localName || attrName;\n\n                if (!toNode.hasAttributeNS(attrNamespaceURI, attrName)) {\n                    fromNode.removeAttributeNS(attrNamespaceURI, attrName);\n                }\n            } else {\n                if (!toNode.hasAttribute(attrName)) {\n                    fromNode.removeAttribute(attrName);\n                }\n            }\n        }\n    }\n}\n\nvar range; // Create a range object for efficently rendering strings to elements.\nvar NS_XHTML = 'http://www.w3.org/1999/xhtml';\n\nvar doc = typeof document === 'undefined' ? undefined : document;\n\n/**\n * This is about the same\n * var html = new DOMParser().parseFromString(str, 'text/html');\n * return html.body.firstChild;\n *\n * @method toElement\n * @param {String} str\n */\nfunction toElement(str) {\n    if (!range && doc.createRange) {\n        range = doc.createRange();\n    }\n\n    var fragment;\n    if (range && range.createContextualFragment) {\n        fragment = range.createContextualFragment(str);\n    } else {\n        fragment = doc.createElement('body');\n        fragment.innerHTML = str;\n    }\n    return fragment.childNodes[0];\n}\n\n/**\n * Returns true if two node's names are the same.\n *\n * NOTE: We don't bother checking `namespaceURI` because you will never find two HTML elements with the same\n *       nodeName and different namespace URIs.\n *\n * @param {Element} a\n * @param {Element} b The target element\n * @return {boolean}\n */\nfunction compareNodeNames(fromEl, toEl) {\n    var fromNodeName = fromEl.nodeName;\n    var toNodeName = toEl.nodeName;\n\n    if (fromNodeName === toNodeName) {\n        return true;\n    }\n\n    if (toEl.actualize &&\n        fromNodeName.charCodeAt(0) < 91 && /* from tag name is upper case */\n        toNodeName.charCodeAt(0) > 90 /* target tag name is lower case */) {\n        // If the target element is a virtual DOM node then we may need to normalize the tag name\n        // before comparing. Normal HTML elements that are in the \"http://www.w3.org/1999/xhtml\"\n        // are converted to upper case\n        return fromNodeName === toNodeName.toUpperCase();\n    } else {\n        return false;\n    }\n}\n\n/**\n * Create an element, optionally with a known namespace URI.\n *\n * @param {string} name the element name, e.g. 'div' or 'svg'\n * @param {string} [namespaceURI] the element's namespace URI, i.e. the value of\n * its `xmlns` attribute or its inferred namespace.\n *\n * @return {Element}\n */\nfunction createElementNS(name, namespaceURI) {\n    return !namespaceURI || namespaceURI === NS_XHTML ?\n        doc.createElement(name) :\n        doc.createElementNS(namespaceURI, name);\n}\n\n/**\n * Copies the children of one DOM element to another DOM element\n */\nfunction moveChildren(fromEl, toEl) {\n    var curChild = fromEl.firstChild;\n    while (curChild) {\n        var nextChild = curChild.nextSibling;\n        toEl.appendChild(curChild);\n        curChild = nextChild;\n    }\n    return toEl;\n}\n\nfunction syncBooleanAttrProp(fromEl, toEl, name) {\n    if (fromEl[name] !== toEl[name]) {\n        fromEl[name] = toEl[name];\n        if (fromEl[name]) {\n            fromEl.setAttribute(name, '');\n        } else {\n            fromEl.removeAttribute(name);\n        }\n    }\n}\n\nvar specialElHandlers = {\n    OPTION: function(fromEl, toEl) {\n        var parentNode = fromEl.parentNode;\n        if (parentNode) {\n            var parentName = parentNode.nodeName.toUpperCase();\n            if (parentName === 'OPTGROUP') {\n                parentNode = parentNode.parentNode;\n                parentName = parentNode && parentNode.nodeName.toUpperCase();\n            }\n            if (parentName === 'SELECT' && !parentNode.hasAttribute('multiple')) {\n                if (fromEl.hasAttribute('selected') && !toEl.selected) {\n                    // Workaround for MS Edge bug where the 'selected' attribute can only be\n                    // removed if set to a non-empty value:\n                    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12087679/\n                    fromEl.setAttribute('selected', 'selected');\n                    fromEl.removeAttribute('selected');\n                }\n                // We have to reset select element's selectedIndex to -1, otherwise setting\n                // fromEl.selected using the syncBooleanAttrProp below has no effect.\n                // The correct selectedIndex will be set in the SELECT special handler below.\n                parentNode.selectedIndex = -1;\n            }\n        }\n        syncBooleanAttrProp(fromEl, toEl, 'selected');\n    },\n    /**\n     * The \"value\" attribute is special for the <input> element since it sets\n     * the initial value. Changing the \"value\" attribute without changing the\n     * \"value\" property will have no effect since it is only used to the set the\n     * initial value.  Similar for the \"checked\" attribute, and \"disabled\".\n     */\n    INPUT: function(fromEl, toEl) {\n        syncBooleanAttrProp(fromEl, toEl, 'checked');\n        syncBooleanAttrProp(fromEl, toEl, 'disabled');\n\n        if (fromEl.value !== toEl.value) {\n            fromEl.value = toEl.value;\n        }\n\n        if (!toEl.hasAttribute('value')) {\n            fromEl.removeAttribute('value');\n        }\n    },\n\n    TEXTAREA: function(fromEl, toEl) {\n        var newValue = toEl.value;\n        if (fromEl.value !== newValue) {\n            fromEl.value = newValue;\n        }\n\n        var firstChild = fromEl.firstChild;\n        if (firstChild) {\n            // Needed for IE. Apparently IE sets the placeholder as the\n            // node value and vise versa. This ignores an empty update.\n            var oldValue = firstChild.nodeValue;\n\n            if (oldValue == newValue || (!newValue && oldValue == fromEl.placeholder)) {\n                return;\n            }\n\n            firstChild.nodeValue = newValue;\n        }\n    },\n    SELECT: function(fromEl, toEl) {\n        if (!toEl.hasAttribute('multiple')) {\n            var selectedIndex = -1;\n            var i = 0;\n            // We have to loop through children of fromEl, not toEl since nodes can be moved\n            // from toEl to fromEl directly when morphing.\n            // At the time this special handler is invoked, all children have already been morphed\n            // and appended to / removed from fromEl, so using fromEl here is safe and correct.\n            var curChild = fromEl.firstChild;\n            var optgroup;\n            var nodeName;\n            while(curChild) {\n                nodeName = curChild.nodeName && curChild.nodeName.toUpperCase();\n                if (nodeName === 'OPTGROUP') {\n                    optgroup = curChild;\n                    curChild = optgroup.firstChild;\n                } else {\n                    if (nodeName === 'OPTION') {\n                        if (curChild.hasAttribute('selected')) {\n                            selectedIndex = i;\n                            break;\n                        }\n                        i++;\n                    }\n                    curChild = curChild.nextSibling;\n                    if (!curChild && optgroup) {\n                        curChild = optgroup.nextSibling;\n                        optgroup = null;\n                    }\n                }\n            }\n\n            fromEl.selectedIndex = selectedIndex;\n        }\n    }\n};\n\nvar ELEMENT_NODE = 1;\nvar TEXT_NODE = 3;\nvar COMMENT_NODE = 8;\n\nfunction noop() {}\n\nfunction defaultGetNodeKey(node) {\n    return node.id;\n}\n\nfunction morphdomFactory(morphAttrs) {\n\n    return function morphdom(fromNode, toNode, options) {\n        if (!options) {\n            options = {};\n        }\n\n        if (typeof toNode === 'string') {\n            if (fromNode.nodeName === '#document' || fromNode.nodeName === 'HTML') {\n                var toNodeHtml = toNode;\n                toNode = doc.createElement('html');\n                toNode.innerHTML = toNodeHtml;\n            } else {\n                toNode = toElement(toNode);\n            }\n        }\n\n        var getNodeKey = options.getNodeKey || defaultGetNodeKey;\n        var onBeforeNodeAdded = options.onBeforeNodeAdded || noop;\n        var onNodeAdded = options.onNodeAdded || noop;\n        var onBeforeElUpdated = options.onBeforeElUpdated || noop;\n        var onElUpdated = options.onElUpdated || noop;\n        var onBeforeNodeDiscarded = options.onBeforeNodeDiscarded || noop;\n        var onNodeDiscarded = options.onNodeDiscarded || noop;\n        var onBeforeElChildrenUpdated = options.onBeforeElChildrenUpdated || noop;\n        var childrenOnly = options.childrenOnly === true;\n\n        // This object is used as a lookup to quickly find all keyed elements in the original DOM tree.\n        var fromNodesLookup = {};\n        var keyedRemovalList;\n\n        function addKeyedRemoval(key) {\n            if (keyedRemovalList) {\n                keyedRemovalList.push(key);\n            } else {\n                keyedRemovalList = [key];\n            }\n        }\n\n        function walkDiscardedChildNodes(node, skipKeyedNodes) {\n            if (node.nodeType === ELEMENT_NODE) {\n                var curChild = node.firstChild;\n                while (curChild) {\n\n                    var key = undefined;\n\n                    if (skipKeyedNodes && (key = getNodeKey(curChild))) {\n                        // If we are skipping keyed nodes then we add the key\n                        // to a list so that it can be handled at the very end.\n                        addKeyedRemoval(key);\n                    } else {\n                        // Only report the node as discarded if it is not keyed. We do this because\n                        // at the end we loop through all keyed elements that were unmatched\n                        // and then discard them in one final pass.\n                        onNodeDiscarded(curChild);\n                        if (curChild.firstChild) {\n                            walkDiscardedChildNodes(curChild, skipKeyedNodes);\n                        }\n                    }\n\n                    curChild = curChild.nextSibling;\n                }\n            }\n        }\n\n        /**\n         * Removes a DOM node out of the original DOM\n         *\n         * @param  {Node} node The node to remove\n         * @param  {Node} parentNode The nodes parent\n         * @param  {Boolean} skipKeyedNodes If true then elements with keys will be skipped and not discarded.\n         * @return {undefined}\n         */\n        function removeNode(node, parentNode, skipKeyedNodes) {\n            if (onBeforeNodeDiscarded(node) === false) {\n                return;\n            }\n\n            if (parentNode) {\n                parentNode.removeChild(node);\n            }\n\n            onNodeDiscarded(node);\n            walkDiscardedChildNodes(node, skipKeyedNodes);\n        }\n\n        // // TreeWalker implementation is no faster, but keeping this around in case this changes in the future\n        // function indexTree(root) {\n        //     var treeWalker = document.createTreeWalker(\n        //         root,\n        //         NodeFilter.SHOW_ELEMENT);\n        //\n        //     var el;\n        //     while((el = treeWalker.nextNode())) {\n        //         var key = getNodeKey(el);\n        //         if (key) {\n        //             fromNodesLookup[key] = el;\n        //         }\n        //     }\n        // }\n\n        // // NodeIterator implementation is no faster, but keeping this around in case this changes in the future\n        //\n        // function indexTree(node) {\n        //     var nodeIterator = document.createNodeIterator(node, NodeFilter.SHOW_ELEMENT);\n        //     var el;\n        //     while((el = nodeIterator.nextNode())) {\n        //         var key = getNodeKey(el);\n        //         if (key) {\n        //             fromNodesLookup[key] = el;\n        //         }\n        //     }\n        // }\n\n        function indexTree(node) {\n            if (node.nodeType === ELEMENT_NODE) {\n                var curChild = node.firstChild;\n                while (curChild) {\n                    var key = getNodeKey(curChild);\n                    if (key) {\n                        fromNodesLookup[key] = curChild;\n                    }\n\n                    // Walk recursively\n                    indexTree(curChild);\n\n                    curChild = curChild.nextSibling;\n                }\n            }\n        }\n\n        indexTree(fromNode);\n\n        function handleNodeAdded(el) {\n            onNodeAdded(el);\n\n            var curChild = el.firstChild;\n            while (curChild) {\n                var nextSibling = curChild.nextSibling;\n\n                var key = getNodeKey(curChild);\n                if (key) {\n                    var unmatchedFromEl = fromNodesLookup[key];\n                    if (unmatchedFromEl && compareNodeNames(curChild, unmatchedFromEl)) {\n                        curChild.parentNode.replaceChild(unmatchedFromEl, curChild);\n                        morphChildren(unmatchedFromEl, curChild);\n                    }\n                }\n\n                handleNodeAdded(curChild);\n                curChild = nextSibling;\n            }\n        }\n\n        function morphChildren(fromEl, toEl, childrenOnly) {\n            var toElKey = getNodeKey(toEl);\n            var curFromNodeKey;\n\n            if (toElKey) {\n                // If an element with an ID is being morphed then it will be in the final\n                // DOM so clear it out of the saved elements collection\n                delete fromNodesLookup[toElKey];\n            }\n\n            if (toNode.isSameNode && toNode.isSameNode(fromNode)) {\n                return;\n            }\n\n            if (!childrenOnly) {\n                // optional\n                if (onBeforeElUpdated(fromEl, toEl) === false) {\n                    return;\n                }\n\n                // update attributes on original DOM element first\n                morphAttrs(fromEl, toEl);\n                // optional\n                onElUpdated(fromEl);\n\n                if (onBeforeElChildrenUpdated(fromEl, toEl) === false) {\n                    return;\n                }\n            }\n\n            if (fromEl.nodeName !== 'TEXTAREA') {\n                var curToNodeChild = toEl.firstChild;\n                var curFromNodeChild = fromEl.firstChild;\n                var curToNodeKey;\n\n                var fromNextSibling;\n                var toNextSibling;\n                var matchingFromEl;\n\n                // walk the children\n                outer: while (curToNodeChild) {\n                    toNextSibling = curToNodeChild.nextSibling;\n                    curToNodeKey = getNodeKey(curToNodeChild);\n\n                    // walk the fromNode children all the way through\n                    while (curFromNodeChild) {\n                        fromNextSibling = curFromNodeChild.nextSibling;\n\n                        if (curToNodeChild.isSameNode && curToNodeChild.isSameNode(curFromNodeChild)) {\n                            curToNodeChild = toNextSibling;\n                            curFromNodeChild = fromNextSibling;\n                            continue outer;\n                        }\n\n                        curFromNodeKey = getNodeKey(curFromNodeChild);\n\n                        var curFromNodeType = curFromNodeChild.nodeType;\n\n                        var isCompatible = undefined;\n\n                        if (curFromNodeType === curToNodeChild.nodeType) {\n                            if (curFromNodeType === ELEMENT_NODE) {\n                                // Both nodes being compared are Element nodes\n\n                                if (curToNodeKey) {\n                                    // The target node has a key so we want to match it up with the correct element\n                                    // in the original DOM tree\n                                    if (curToNodeKey !== curFromNodeKey) {\n                                        // The current element in the original DOM tree does not have a matching key so\n                                        // let's check our lookup to see if there is a matching element in the original\n                                        // DOM tree\n                                        if ((matchingFromEl = fromNodesLookup[curToNodeKey])) {\n                                            if (fromNextSibling === matchingFromEl) {\n                                                // Special case for single element removals. To avoid removing the original\n                                                // DOM node out of the tree (since that can break CSS transitions, etc.),\n                                                // we will instead discard the current node and wait until the next\n                                                // iteration to properly match up the keyed target element with its matching\n                                                // element in the original tree\n                                                isCompatible = false;\n                                            } else {\n                                                // We found a matching keyed element somewhere in the original DOM tree.\n                                                // Let's move the original DOM node into the current position and morph\n                                                // it.\n\n                                                // NOTE: We use insertBefore instead of replaceChild because we want to go through\n                                                // the `removeNode()` function for the node that is being discarded so that\n                                                // all lifecycle hooks are correctly invoked\n                                                fromEl.insertBefore(matchingFromEl, curFromNodeChild);\n\n                                                // fromNextSibling = curFromNodeChild.nextSibling;\n\n                                                if (curFromNodeKey) {\n                                                    // Since the node is keyed it might be matched up later so we defer\n                                                    // the actual removal to later\n                                                    addKeyedRemoval(curFromNodeKey);\n                                                } else {\n                                                    // NOTE: we skip nested keyed nodes from being removed since there is\n                                                    //       still a chance they will be matched up later\n                                                    removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n                                                }\n\n                                                curFromNodeChild = matchingFromEl;\n                                            }\n                                        } else {\n                                            // The nodes are not compatible since the \"to\" node has a key and there\n                                            // is no matching keyed node in the source tree\n                                            isCompatible = false;\n                                        }\n                                    }\n                                } else if (curFromNodeKey) {\n                                    // The original has a key\n                                    isCompatible = false;\n                                }\n\n                                isCompatible = isCompatible !== false && compareNodeNames(curFromNodeChild, curToNodeChild);\n                                if (isCompatible) {\n                                    // We found compatible DOM elements so transform\n                                    // the current \"from\" node to match the current\n                                    // target DOM node.\n                                    // MORPH\n                                    morphChildren(curFromNodeChild, curToNodeChild);\n                                }\n\n                            } else if (curFromNodeType === TEXT_NODE || curFromNodeType == COMMENT_NODE) {\n                                // Both nodes being compared are Text or Comment nodes\n                                isCompatible = true;\n                                // Simply update nodeValue on the original node to\n                                // change the text value\n                                if (curFromNodeChild.nodeValue !== curToNodeChild.nodeValue) {\n                                    curFromNodeChild.nodeValue = curToNodeChild.nodeValue;\n                                }\n\n                            }\n                        }\n\n                        if (isCompatible) {\n                            // Advance both the \"to\" child and the \"from\" child since we found a match\n                            curToNodeChild = toNextSibling;\n                            curFromNodeChild = fromNextSibling;\n                            continue outer;\n                        }\n\n                        // No compatible match so remove the old node from the DOM and continue trying to find a\n                        // match in the original DOM. However, we only do this if the from node is not keyed\n                        // since it is possible that a keyed node might match up with a node somewhere else in the\n                        // target tree and we don't want to discard it just yet since it still might find a\n                        // home in the final DOM tree. After everything is done we will remove any keyed nodes\n                        // that didn't find a home\n                        if (curFromNodeKey) {\n                            // Since the node is keyed it might be matched up later so we defer\n                            // the actual removal to later\n                            addKeyedRemoval(curFromNodeKey);\n                        } else {\n                            // NOTE: we skip nested keyed nodes from being removed since there is\n                            //       still a chance they will be matched up later\n                            removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n                        }\n\n                        curFromNodeChild = fromNextSibling;\n                    } // END: while(curFromNodeChild) {}\n\n                    // If we got this far then we did not find a candidate match for\n                    // our \"to node\" and we exhausted all of the children \"from\"\n                    // nodes. Therefore, we will just append the current \"to\" node\n                    // to the end\n                    if (curToNodeKey && (matchingFromEl = fromNodesLookup[curToNodeKey]) && compareNodeNames(matchingFromEl, curToNodeChild)) {\n                        fromEl.appendChild(matchingFromEl);\n                        // MORPH\n                        morphChildren(matchingFromEl, curToNodeChild);\n                    } else {\n                        var onBeforeNodeAddedResult = onBeforeNodeAdded(curToNodeChild);\n                        if (onBeforeNodeAddedResult !== false) {\n                            if (onBeforeNodeAddedResult) {\n                                curToNodeChild = onBeforeNodeAddedResult;\n                            }\n\n                            if (curToNodeChild.actualize) {\n                                curToNodeChild = curToNodeChild.actualize(fromEl.ownerDocument || doc);\n                            }\n                            fromEl.appendChild(curToNodeChild);\n                            handleNodeAdded(curToNodeChild);\n                        }\n                    }\n\n                    curToNodeChild = toNextSibling;\n                    curFromNodeChild = fromNextSibling;\n                }\n\n                // We have processed all of the \"to nodes\". If curFromNodeChild is\n                // non-null then we still have some from nodes left over that need\n                // to be removed\n                while (curFromNodeChild) {\n                    fromNextSibling = curFromNodeChild.nextSibling;\n                    if ((curFromNodeKey = getNodeKey(curFromNodeChild))) {\n                        // Since the node is keyed it might be matched up later so we defer\n                        // the actual removal to later\n                        addKeyedRemoval(curFromNodeKey);\n                    } else {\n                        // NOTE: we skip nested keyed nodes from being removed since there is\n                        //       still a chance they will be matched up later\n                        removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n                    }\n                    curFromNodeChild = fromNextSibling;\n                }\n            }\n\n            var specialElHandler = specialElHandlers[fromEl.nodeName];\n            if (specialElHandler) {\n                specialElHandler(fromEl, toEl);\n            }\n        } // END: morphChildren(...)\n\n        var morphedNode = fromNode;\n        var morphedNodeType = morphedNode.nodeType;\n        var toNodeType = toNode.nodeType;\n\n        if (!childrenOnly) {\n            // Handle the case where we are given two DOM nodes that are not\n            // compatible (e.g. <div> --> <span> or <div> --> TEXT)\n            if (morphedNodeType === ELEMENT_NODE) {\n                if (toNodeType === ELEMENT_NODE) {\n                    if (!compareNodeNames(fromNode, toNode)) {\n                        onNodeDiscarded(fromNode);\n                        morphedNode = moveChildren(fromNode, createElementNS(toNode.nodeName, toNode.namespaceURI));\n                    }\n                } else {\n                    // Going from an element node to a text node\n                    morphedNode = toNode;\n                }\n            } else if (morphedNodeType === TEXT_NODE || morphedNodeType === COMMENT_NODE) { // Text or comment node\n                if (toNodeType === morphedNodeType) {\n                    if (morphedNode.nodeValue !== toNode.nodeValue) {\n                        morphedNode.nodeValue = toNode.nodeValue;\n                    }\n\n                    return morphedNode;\n                } else {\n                    // Text node to something else\n                    morphedNode = toNode;\n                }\n            }\n        }\n\n        if (morphedNode === toNode) {\n            // The \"to node\" was not compatible with the \"from node\" so we had to\n            // toss out the \"from node\" and use the \"to node\"\n            onNodeDiscarded(fromNode);\n        } else {\n            morphChildren(morphedNode, toNode, childrenOnly);\n\n            // We now need to loop over any keyed nodes that might need to be\n            // removed. We only do the removal if we know that the keyed node\n            // never found a match. When a keyed node is matched up we remove\n            // it out of fromNodesLookup and we use fromNodesLookup to determine\n            // if a keyed node has been matched up or not\n            if (keyedRemovalList) {\n                for (var i=0, len=keyedRemovalList.length; i<len; i++) {\n                    var elToRemove = fromNodesLookup[keyedRemovalList[i]];\n                    if (elToRemove) {\n                        removeNode(elToRemove, elToRemove.parentNode, false);\n                    }\n                }\n            }\n        }\n\n        if (!childrenOnly && morphedNode !== fromNode && fromNode.parentNode) {\n            if (morphedNode.actualize) {\n                morphedNode = morphedNode.actualize(fromNode.ownerDocument || doc);\n            }\n            // If we had to swap out the from node with a new node because the old\n            // node was not compatible with the target node then we need to\n            // replace the old DOM node in the original DOM tree. This is only\n            // possible if the original DOM node was part of a DOM tree which\n            // we know is the case if it has a parent node.\n            fromNode.parentNode.replaceChild(morphedNode, fromNode);\n        }\n\n        return morphedNode;\n    };\n}\n\nvar morphdom = morphdomFactory(morphAttrs);\n\n/* harmony default export */ __webpack_exports__[\"a\"] = morphdom;\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(1);\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// virtualized-list.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 5);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 94a7992885f4de7c0c1a","import morphdom from 'morphdom';\nimport SizeAndPositionManager from './SizeAndPositionManager';\n\nconst STYLE_INNER = 'position:relative; overflow:hidden; width:100%; min-height:100%; will-change: transform;';\nconst STYLE_CONTENT = 'position:absolute; top:0; left:0; height:100%; width:100%; overflow:visible;';\n\nexport default class VirtualizedList {\n  constructor(container, options) {\n    this.container = container;\n    this.options = options;\n\n    // Initialization\n    this.state = {};\n    this._initializeSizeAndPositionManager(options.rowCount);\n\n    // Binding\n    this.render = this.render.bind(this);\n    this.handleScroll = this.handleScroll.bind(this);\n\n    // Lifecycle Methods\n    this.componentDidMount();\n  }\n\n  componentDidMount() {\n    const {onMount, initialScrollTop, initialIndex, height} = this.options;\n    const offset = (\n      initialScrollTop ||\n      initialIndex != null && this.getRowOffset(initialIndex) ||\n      0\n    );\n    const inner = this.inner = document.createElement('div');\n    const content = this.content = document.createElement('div');\n\n    inner.setAttribute('style', STYLE_INNER);\n    content.setAttribute('style', STYLE_CONTENT);\n    inner.appendChild(content);\n    this.container.appendChild(inner);\n\n    this.setState({\n      offset,\n      height,\n    }, () => {\n      if (offset) {\n        this.container.scrollTop = offset;\n      }\n\n      // Add event listeners\n      this.container.addEventListener('scroll', this.handleScroll);\n\n      if (typeof onMount === 'function') {\n        onMount();\n      }\n    });\n  }\n\n  _initializeSizeAndPositionManager(count) {\n    this._sizeAndPositionManager = new SizeAndPositionManager({\n      itemCount: count,\n      itemSizeGetter: this.getRowHeight,\n      estimatedItemSize: this.options.estimatedRowHeight || 100\n    });\n  }\n\n  setState(state = {}, callback) {\n    this.state = Object.assign(this.state, state);\n\n    requestAnimationFrame(() => {\n      this.render();\n\n      if (typeof callback === 'function') {\n        callback();\n      }\n    });\n  }\n\n  resize(height, callback) {\n    this.setState({\n      height,\n    }, callback);\n  }\n\n  handleScroll(e) {\n    const {onScroll} = this.options;\n    const offset = this.container.scrollTop;\n\n    this.setState({offset});\n\n    if (typeof onScroll === 'function') {\n      onScroll(offset, e);\n    }\n  }\n\n  getRowHeight = ({index}) => {\n    const {rowHeight} = this.options;\n\n    if (typeof rowHeight === 'function') {\n      return rowHeight(index);\n    }\n\n    return (Array.isArray(rowHeight)) ? rowHeight[index] : rowHeight;\n  }\n\n  getRowOffset(index) {\n    const {offset} = this._sizeAndPositionManager.getSizeAndPositionForIndex(index);\n\n    return offset;\n  }\n\n  scrollToIndex(index, alignment) {\n    const {height} = this.state;\n    const offset = this._sizeAndPositionManager.getUpdatedOffsetForIndex({\n      align: alignment,\n      containerSize: height,\n      targetIndex: index,\n    });\n\n    this.container.scrollTop = offset;\n  }\n\n  setRowCount(count) {\n    this._initializeSizeAndPositionManager(count);\n    this.render();\n  }\n\n  onRowsRendered(renderedRows) {\n    const {onRowsRendered} = this.options;\n\n    if (typeof onRowsRendered === 'function') {\n      onRowsRendered(renderedRows);\n    }\n  }\n\n  destroy() {\n    this.container.removeEventListener('scroll', this.handleScroll);\n    this.container.innerHTML = '';\n  }\n\n  render() {\n    const {overscanCount, renderRow} = this.options;\n    const {height, offset = 0} = this.state;\n    const {start, stop} = this._sizeAndPositionManager.getVisibleRange({\n      containerSize: height,\n      offset,\n      overscanCount,\n    });\n    const fragment = document.createDocumentFragment();\n\n    for (let index = start; index <= stop; index++) {\n      fragment.appendChild(renderRow(index));\n    }\n\n    this.inner.style.height = `${this._sizeAndPositionManager.getTotalSize()}px`;\n    this.content.style.top = `${this.getRowOffset(start)}px`;\n\n    morphdom(this.content, fragment, {\n      childrenOnly: true,\n      getNodeKey: node => node.id,\n    });\n\n    this.onRowsRendered({\n      startIndex: start,\n      stopIndex: stop,\n    });\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/VirtualList/index.js","import VirtualList from '../VirtualList';\n\nexport default class InfiniteVirtualList extends VirtualList {\n  onRowsRendered({startIndex, stopIndex}) {\n    const {\n      isRowLoaded,\n      loadMoreRows,\n      minimumBatchSize = 10,\n      rowCount = 0,\n      threshold = 15,\n    } = this.options;\n\n    const unloadedRanges = getUnloadedRanges({\n      isRowLoaded,\n      minimumBatchSize,\n      rowCount,\n      startIndex: Math.max(0, startIndex - threshold),\n      stopIndex: Math.min(rowCount - 1, stopIndex + threshold),\n    });\n\n    unloadedRanges.forEach(unloadedRange => {\n      let promise = loadMoreRows(unloadedRange);\n\n      if (promise) {\n        promise.then(() => {\n          // Refresh the visible rows if any of them have just been loaded.\n          // Otherwise they will remain in their unloaded visual state.\n          if (\n            isRangeVisible({\n              lastRenderedStartIndex: startIndex,\n              lastRenderedStopIndex: stopIndex,\n              startIndex: unloadedRange.startIndex,\n              stopIndex: unloadedRange.stopIndex,\n            })\n          ) {\n            // Force update\n            this.render();\n          }\n        });\n      }\n    });\n  }\n}\n\n/**\n * Determines if the specified start/stop range is visible based on the most recently rendered range.\n */\nexport function isRangeVisible ({\n  lastRenderedStartIndex,\n  lastRenderedStopIndex,\n  startIndex,\n  stopIndex\n}) {\n  return !(startIndex > lastRenderedStopIndex || stopIndex < lastRenderedStartIndex);\n}\n\n/**\n * Returns all of the ranges within a larger range that contain unloaded rows.\n */\nexport function getUnloadedRanges ({\n  isRowLoaded,\n  minimumBatchSize,\n  rowCount,\n  startIndex,\n  stopIndex\n}) {\n  const unloadedRanges = [];\n  let rangeStartIndex = null;\n  let rangeStopIndex = null;\n\n  for (let index = startIndex; index <= stopIndex; index++) {\n    let loaded = isRowLoaded(index);\n\n    if (!loaded) {\n      rangeStopIndex = index;\n      if (rangeStartIndex === null) {\n        rangeStartIndex = index;\n      }\n    } else if (rangeStopIndex !== null) {\n      unloadedRanges.push({\n        startIndex: rangeStartIndex,\n        stopIndex: rangeStopIndex,\n      });\n\n      rangeStartIndex = rangeStopIndex = null;\n    }\n  }\n\n  // If :rangeStopIndex is not null it means we haven't ran out of unloaded rows.\n  // Scan forward to try filling our :minimumBatchSize.\n  if (rangeStopIndex !== null) {\n    const potentialStopIndex = Math.min(\n      Math.max(rangeStopIndex, rangeStartIndex + minimumBatchSize - 1),\n      rowCount - 1,\n    );\n\n    for (let index = rangeStopIndex + 1; index <= potentialStopIndex; index++) {\n      if (!isRowLoaded({index})) {\n        rangeStopIndex = index;\n      } else {\n        break;\n      }\n    }\n\n    unloadedRanges.push({\n      startIndex: rangeStartIndex,\n      stopIndex: rangeStopIndex,\n    });\n  }\n\n  // Check to see if our first range ended prematurely.\n  // In this case we should scan backwards to try filling our :minimumBatchSize.\n  if (unloadedRanges.length) {\n    const firstUnloadedRange = unloadedRanges[0];\n\n    while (\n      firstUnloadedRange.stopIndex - firstUnloadedRange.startIndex + 1 < minimumBatchSize &&\n      firstUnloadedRange.startIndex > 0\n    ) {\n      let index = firstUnloadedRange.startIndex - 1;\n\n      if (!isRowLoaded({index})) {\n        firstUnloadedRange.startIndex = index;\n      } else {\n        break;\n      }\n    }\n  }\n\n\n  return unloadedRanges;\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/InfiniteVirtualList/index.js","/* Forked from react-virtualized 💖 */\nexport const ALIGN_START = 'start';\nexport const ALIGN_CENTER = 'center';\nexport const ALIGN_END = 'end';\n\nexport default class SizeAndPositionManager {\n  constructor({\n    itemCount,\n    itemSizeGetter,\n    estimatedItemSize,\n  }) {\n    this._itemSizeGetter = itemSizeGetter;\n    this._itemCount = itemCount;\n    this._estimatedItemSize = estimatedItemSize;\n\n    // Cache of size and position data for items, mapped by item index.\n    this._itemSizeAndPositionData = {};\n\n    // Measurements for items up to this index can be trusted; items afterward should be estimated.\n    this._lastMeasuredIndex = -1;\n  }\n\n  getLastMeasuredIndex() {\n    return this._lastMeasuredIndex;\n  }\n\n  /**\n   * This method returns the size and position for the item at the specified index.\n   * It just-in-time calculates (or used cached values) for items leading up to the index.\n   */\n  getSizeAndPositionForIndex(index) {\n    if (index < 0 || index >= this._itemCount) {\n      throw Error(`Requested index ${index} is outside of range 0..${this._itemCount}`);\n    }\n\n    if (index > this._lastMeasuredIndex) {\n      let lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\n      let offset = lastMeasuredSizeAndPosition.offset +\n        lastMeasuredSizeAndPosition.size;\n\n      for (var i = this._lastMeasuredIndex + 1; i <= index; i++) {\n        let size = this._itemSizeGetter({index: i});\n\n        if (size == null || isNaN(size)) {\n          throw Error(`Invalid size returned for index ${i} of value ${size}`);\n        }\n\n        this._itemSizeAndPositionData[i] = {\n          offset,\n          size,\n        };\n\n        offset += size;\n      }\n\n      this._lastMeasuredIndex = index;\n    }\n\n    return this._itemSizeAndPositionData[index];\n  }\n\n  getSizeAndPositionOfLastMeasuredItem() {\n    return this._lastMeasuredIndex >= 0\n      ? this._itemSizeAndPositionData[this._lastMeasuredIndex]\n      : {offset: 0, size: 0};\n  }\n\n  /**\n  * Total size of all items being measured.\n  * This value will be completedly estimated initially.\n  * As items as measured the estimate will be updated.\n  */\n  getTotalSize() {\n    const lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\n\n    return lastMeasuredSizeAndPosition.offset + lastMeasuredSizeAndPosition.size + (this._itemCount - this._lastMeasuredIndex - 1) * this._estimatedItemSize;\n  }\n\n  /**\n   * Determines a new offset that ensures a certain item is visible, given the alignment.\n   *\n   * @param align Desired alignment within container; one of \"start\" (default), \"center\", or \"end\"\n   * @param containerSize Size (width or height) of the container viewport\n   * @return Offset to use to ensure the specified item is visible\n   */\n  getUpdatedOffsetForIndex({\n    align = ALIGN_START,\n    containerSize,\n    targetIndex,\n  }) {\n    if (containerSize <= 0) {\n      return 0;\n    }\n\n    const datum = this.getSizeAndPositionForIndex(targetIndex);\n    const maxOffset = datum.offset;\n    const minOffset = maxOffset - containerSize + datum.size;\n\n    let idealOffset;\n\n    switch (align) {\n      case ALIGN_END:\n        idealOffset = minOffset;\n        break;\n      case ALIGN_CENTER:\n        idealOffset = maxOffset - (containerSize - datum.size) / 2;\n        break;\n      default:\n        idealOffset = maxOffset;\n        break;\n    }\n\n    const totalSize = this.getTotalSize();\n\n    return Math.max(0, Math.min(totalSize - containerSize, idealOffset));\n  }\n\n  getVisibleRange({containerSize, offset, overscanCount}) {\n    const totalSize = this.getTotalSize();\n\n    if (totalSize === 0) { return {}; }\n\n    const maxOffset = offset + containerSize;\n    let start = this._findNearestItem(offset);\n    let stop = start;\n\n    const datum = this.getSizeAndPositionForIndex(start);\n    offset = datum.offset + datum.size;\n\n    while (offset < maxOffset && stop < this._itemCount - 1) {\n      stop++;\n      offset += this.getSizeAndPositionForIndex(stop).size;\n    }\n\n    if (overscanCount) {\n      start = Math.max(0, start - overscanCount);\n      stop = Math.min(stop + overscanCount, this._itemCount);\n    }\n\n    return {\n      start,\n      stop,\n    };\n  }\n\n  /**\n   * Clear all cached values for items after the specified index.\n   * This method should be called for any item that has changed its size.\n   * It will not immediately perform any calculations; they'll be performed the next time getSizeAndPositionForIndex() is called.\n   */\n  resetItem(index) {\n    this._lastMeasuredIndex = Math.min(this._lastMeasuredIndex, index - 1);\n  }\n\n  _binarySearch({low, high, offset}) {\n    let middle;\n    let currentOffset;\n\n    while (low <= high) {\n      middle = low + Math.floor((high - low) / 2);\n      currentOffset = this.getSizeAndPositionForIndex(middle).offset;\n\n      if (currentOffset === offset) {\n        return middle;\n      } else if (currentOffset < offset) {\n        low = middle + 1;\n      } else if (currentOffset > offset) {\n        high = middle - 1;\n      }\n    }\n\n    if (low > 0) {\n      return low - 1;\n    }\n  }\n\n  _exponentialSearch({index, offset}) {\n    let interval = 1;\n\n    while (\n      index < this._itemCount &&\n      this.getSizeAndPositionForIndex(index).offset < offset\n    ) {\n      index += interval;\n      interval *= 2;\n    }\n\n    return this._binarySearch({\n      high: Math.min(index, this._itemCount - 1),\n      low: Math.floor(index / 2),\n      offset,\n    });\n  }\n\n  /**\n   * Searches for the item (index) nearest the specified offset.\n   *\n   * If no exact match is found the next lowest item index will be returned.\n   * This allows partially visible items (with offsets just before/above the fold) to be visible.\n   */\n  _findNearestItem(offset) {\n    if (isNaN(offset)) {\n      throw Error(`Invalid offset ${offset} specified`);\n    }\n\n    // Our search algorithms find the nearest match at or below the specified offset.\n    // So make sure the offset is at least 0 or no match will be found.\n    offset = Math.max(0, offset);\n\n    const lastMeasuredSizeAndPosition = this.getSizeAndPositionOfLastMeasuredItem();\n    const lastMeasuredIndex = Math.max(0, this._lastMeasuredIndex);\n\n    if (lastMeasuredSizeAndPosition.offset >= offset) {\n      // If we've already measured items within this range just use a binary search as it's faster.\n      return this._binarySearch({\n        high: lastMeasuredIndex,\n        low: 0,\n        offset,\n      });\n    } else {\n      // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n      // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n      // The overall complexity for this approach is O(log n).\n      return this._exponentialSearch({\n        index: lastMeasuredIndex,\n        offset,\n      });\n    }\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/VirtualList/SizeAndPositionManager.js","function morphAttrs(fromNode, toNode) {\n    var attrs = toNode.attributes;\n    var i;\n    var attr;\n    var attrName;\n    var attrNamespaceURI;\n    var attrValue;\n    var fromValue;\n\n    // update attributes on original DOM element\n    for (i = attrs.length - 1; i >= 0; --i) {\n        attr = attrs[i];\n        attrName = attr.name;\n        attrNamespaceURI = attr.namespaceURI;\n        attrValue = attr.value;\n\n        if (attrNamespaceURI) {\n            attrName = attr.localName || attrName;\n            fromValue = fromNode.getAttributeNS(attrNamespaceURI, attrName);\n\n            if (fromValue !== attrValue) {\n                fromNode.setAttributeNS(attrNamespaceURI, attrName, attrValue);\n            }\n        } else {\n            fromValue = fromNode.getAttribute(attrName);\n\n            if (fromValue !== attrValue) {\n                fromNode.setAttribute(attrName, attrValue);\n            }\n        }\n    }\n\n    // Remove any extra attributes found on the original DOM element that\n    // weren't found on the target element.\n    attrs = fromNode.attributes;\n\n    for (i = attrs.length - 1; i >= 0; --i) {\n        attr = attrs[i];\n        if (attr.specified !== false) {\n            attrName = attr.name;\n            attrNamespaceURI = attr.namespaceURI;\n\n            if (attrNamespaceURI) {\n                attrName = attr.localName || attrName;\n\n                if (!toNode.hasAttributeNS(attrNamespaceURI, attrName)) {\n                    fromNode.removeAttributeNS(attrNamespaceURI, attrName);\n                }\n            } else {\n                if (!toNode.hasAttribute(attrName)) {\n                    fromNode.removeAttribute(attrName);\n                }\n            }\n        }\n    }\n}\n\nvar range; // Create a range object for efficently rendering strings to elements.\nvar NS_XHTML = 'http://www.w3.org/1999/xhtml';\n\nvar doc = typeof document === 'undefined' ? undefined : document;\n\n/**\n * This is about the same\n * var html = new DOMParser().parseFromString(str, 'text/html');\n * return html.body.firstChild;\n *\n * @method toElement\n * @param {String} str\n */\nfunction toElement(str) {\n    if (!range && doc.createRange) {\n        range = doc.createRange();\n    }\n\n    var fragment;\n    if (range && range.createContextualFragment) {\n        fragment = range.createContextualFragment(str);\n    } else {\n        fragment = doc.createElement('body');\n        fragment.innerHTML = str;\n    }\n    return fragment.childNodes[0];\n}\n\n/**\n * Returns true if two node's names are the same.\n *\n * NOTE: We don't bother checking `namespaceURI` because you will never find two HTML elements with the same\n *       nodeName and different namespace URIs.\n *\n * @param {Element} a\n * @param {Element} b The target element\n * @return {boolean}\n */\nfunction compareNodeNames(fromEl, toEl) {\n    var fromNodeName = fromEl.nodeName;\n    var toNodeName = toEl.nodeName;\n\n    if (fromNodeName === toNodeName) {\n        return true;\n    }\n\n    if (toEl.actualize &&\n        fromNodeName.charCodeAt(0) < 91 && /* from tag name is upper case */\n        toNodeName.charCodeAt(0) > 90 /* target tag name is lower case */) {\n        // If the target element is a virtual DOM node then we may need to normalize the tag name\n        // before comparing. Normal HTML elements that are in the \"http://www.w3.org/1999/xhtml\"\n        // are converted to upper case\n        return fromNodeName === toNodeName.toUpperCase();\n    } else {\n        return false;\n    }\n}\n\n/**\n * Create an element, optionally with a known namespace URI.\n *\n * @param {string} name the element name, e.g. 'div' or 'svg'\n * @param {string} [namespaceURI] the element's namespace URI, i.e. the value of\n * its `xmlns` attribute or its inferred namespace.\n *\n * @return {Element}\n */\nfunction createElementNS(name, namespaceURI) {\n    return !namespaceURI || namespaceURI === NS_XHTML ?\n        doc.createElement(name) :\n        doc.createElementNS(namespaceURI, name);\n}\n\n/**\n * Copies the children of one DOM element to another DOM element\n */\nfunction moveChildren(fromEl, toEl) {\n    var curChild = fromEl.firstChild;\n    while (curChild) {\n        var nextChild = curChild.nextSibling;\n        toEl.appendChild(curChild);\n        curChild = nextChild;\n    }\n    return toEl;\n}\n\nfunction syncBooleanAttrProp(fromEl, toEl, name) {\n    if (fromEl[name] !== toEl[name]) {\n        fromEl[name] = toEl[name];\n        if (fromEl[name]) {\n            fromEl.setAttribute(name, '');\n        } else {\n            fromEl.removeAttribute(name);\n        }\n    }\n}\n\nvar specialElHandlers = {\n    OPTION: function(fromEl, toEl) {\n        var parentNode = fromEl.parentNode;\n        if (parentNode) {\n            var parentName = parentNode.nodeName.toUpperCase();\n            if (parentName === 'OPTGROUP') {\n                parentNode = parentNode.parentNode;\n                parentName = parentNode && parentNode.nodeName.toUpperCase();\n            }\n            if (parentName === 'SELECT' && !parentNode.hasAttribute('multiple')) {\n                if (fromEl.hasAttribute('selected') && !toEl.selected) {\n                    // Workaround for MS Edge bug where the 'selected' attribute can only be\n                    // removed if set to a non-empty value:\n                    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12087679/\n                    fromEl.setAttribute('selected', 'selected');\n                    fromEl.removeAttribute('selected');\n                }\n                // We have to reset select element's selectedIndex to -1, otherwise setting\n                // fromEl.selected using the syncBooleanAttrProp below has no effect.\n                // The correct selectedIndex will be set in the SELECT special handler below.\n                parentNode.selectedIndex = -1;\n            }\n        }\n        syncBooleanAttrProp(fromEl, toEl, 'selected');\n    },\n    /**\n     * The \"value\" attribute is special for the <input> element since it sets\n     * the initial value. Changing the \"value\" attribute without changing the\n     * \"value\" property will have no effect since it is only used to the set the\n     * initial value.  Similar for the \"checked\" attribute, and \"disabled\".\n     */\n    INPUT: function(fromEl, toEl) {\n        syncBooleanAttrProp(fromEl, toEl, 'checked');\n        syncBooleanAttrProp(fromEl, toEl, 'disabled');\n\n        if (fromEl.value !== toEl.value) {\n            fromEl.value = toEl.value;\n        }\n\n        if (!toEl.hasAttribute('value')) {\n            fromEl.removeAttribute('value');\n        }\n    },\n\n    TEXTAREA: function(fromEl, toEl) {\n        var newValue = toEl.value;\n        if (fromEl.value !== newValue) {\n            fromEl.value = newValue;\n        }\n\n        var firstChild = fromEl.firstChild;\n        if (firstChild) {\n            // Needed for IE. Apparently IE sets the placeholder as the\n            // node value and vise versa. This ignores an empty update.\n            var oldValue = firstChild.nodeValue;\n\n            if (oldValue == newValue || (!newValue && oldValue == fromEl.placeholder)) {\n                return;\n            }\n\n            firstChild.nodeValue = newValue;\n        }\n    },\n    SELECT: function(fromEl, toEl) {\n        if (!toEl.hasAttribute('multiple')) {\n            var selectedIndex = -1;\n            var i = 0;\n            // We have to loop through children of fromEl, not toEl since nodes can be moved\n            // from toEl to fromEl directly when morphing.\n            // At the time this special handler is invoked, all children have already been morphed\n            // and appended to / removed from fromEl, so using fromEl here is safe and correct.\n            var curChild = fromEl.firstChild;\n            var optgroup;\n            var nodeName;\n            while(curChild) {\n                nodeName = curChild.nodeName && curChild.nodeName.toUpperCase();\n                if (nodeName === 'OPTGROUP') {\n                    optgroup = curChild;\n                    curChild = optgroup.firstChild;\n                } else {\n                    if (nodeName === 'OPTION') {\n                        if (curChild.hasAttribute('selected')) {\n                            selectedIndex = i;\n                            break;\n                        }\n                        i++;\n                    }\n                    curChild = curChild.nextSibling;\n                    if (!curChild && optgroup) {\n                        curChild = optgroup.nextSibling;\n                        optgroup = null;\n                    }\n                }\n            }\n\n            fromEl.selectedIndex = selectedIndex;\n        }\n    }\n};\n\nvar ELEMENT_NODE = 1;\nvar TEXT_NODE = 3;\nvar COMMENT_NODE = 8;\n\nfunction noop() {}\n\nfunction defaultGetNodeKey(node) {\n    return node.id;\n}\n\nfunction morphdomFactory(morphAttrs) {\n\n    return function morphdom(fromNode, toNode, options) {\n        if (!options) {\n            options = {};\n        }\n\n        if (typeof toNode === 'string') {\n            if (fromNode.nodeName === '#document' || fromNode.nodeName === 'HTML') {\n                var toNodeHtml = toNode;\n                toNode = doc.createElement('html');\n                toNode.innerHTML = toNodeHtml;\n            } else {\n                toNode = toElement(toNode);\n            }\n        }\n\n        var getNodeKey = options.getNodeKey || defaultGetNodeKey;\n        var onBeforeNodeAdded = options.onBeforeNodeAdded || noop;\n        var onNodeAdded = options.onNodeAdded || noop;\n        var onBeforeElUpdated = options.onBeforeElUpdated || noop;\n        var onElUpdated = options.onElUpdated || noop;\n        var onBeforeNodeDiscarded = options.onBeforeNodeDiscarded || noop;\n        var onNodeDiscarded = options.onNodeDiscarded || noop;\n        var onBeforeElChildrenUpdated = options.onBeforeElChildrenUpdated || noop;\n        var childrenOnly = options.childrenOnly === true;\n\n        // This object is used as a lookup to quickly find all keyed elements in the original DOM tree.\n        var fromNodesLookup = {};\n        var keyedRemovalList;\n\n        function addKeyedRemoval(key) {\n            if (keyedRemovalList) {\n                keyedRemovalList.push(key);\n            } else {\n                keyedRemovalList = [key];\n            }\n        }\n\n        function walkDiscardedChildNodes(node, skipKeyedNodes) {\n            if (node.nodeType === ELEMENT_NODE) {\n                var curChild = node.firstChild;\n                while (curChild) {\n\n                    var key = undefined;\n\n                    if (skipKeyedNodes && (key = getNodeKey(curChild))) {\n                        // If we are skipping keyed nodes then we add the key\n                        // to a list so that it can be handled at the very end.\n                        addKeyedRemoval(key);\n                    } else {\n                        // Only report the node as discarded if it is not keyed. We do this because\n                        // at the end we loop through all keyed elements that were unmatched\n                        // and then discard them in one final pass.\n                        onNodeDiscarded(curChild);\n                        if (curChild.firstChild) {\n                            walkDiscardedChildNodes(curChild, skipKeyedNodes);\n                        }\n                    }\n\n                    curChild = curChild.nextSibling;\n                }\n            }\n        }\n\n        /**\n         * Removes a DOM node out of the original DOM\n         *\n         * @param  {Node} node The node to remove\n         * @param  {Node} parentNode The nodes parent\n         * @param  {Boolean} skipKeyedNodes If true then elements with keys will be skipped and not discarded.\n         * @return {undefined}\n         */\n        function removeNode(node, parentNode, skipKeyedNodes) {\n            if (onBeforeNodeDiscarded(node) === false) {\n                return;\n            }\n\n            if (parentNode) {\n                parentNode.removeChild(node);\n            }\n\n            onNodeDiscarded(node);\n            walkDiscardedChildNodes(node, skipKeyedNodes);\n        }\n\n        // // TreeWalker implementation is no faster, but keeping this around in case this changes in the future\n        // function indexTree(root) {\n        //     var treeWalker = document.createTreeWalker(\n        //         root,\n        //         NodeFilter.SHOW_ELEMENT);\n        //\n        //     var el;\n        //     while((el = treeWalker.nextNode())) {\n        //         var key = getNodeKey(el);\n        //         if (key) {\n        //             fromNodesLookup[key] = el;\n        //         }\n        //     }\n        // }\n\n        // // NodeIterator implementation is no faster, but keeping this around in case this changes in the future\n        //\n        // function indexTree(node) {\n        //     var nodeIterator = document.createNodeIterator(node, NodeFilter.SHOW_ELEMENT);\n        //     var el;\n        //     while((el = nodeIterator.nextNode())) {\n        //         var key = getNodeKey(el);\n        //         if (key) {\n        //             fromNodesLookup[key] = el;\n        //         }\n        //     }\n        // }\n\n        function indexTree(node) {\n            if (node.nodeType === ELEMENT_NODE) {\n                var curChild = node.firstChild;\n                while (curChild) {\n                    var key = getNodeKey(curChild);\n                    if (key) {\n                        fromNodesLookup[key] = curChild;\n                    }\n\n                    // Walk recursively\n                    indexTree(curChild);\n\n                    curChild = curChild.nextSibling;\n                }\n            }\n        }\n\n        indexTree(fromNode);\n\n        function handleNodeAdded(el) {\n            onNodeAdded(el);\n\n            var curChild = el.firstChild;\n            while (curChild) {\n                var nextSibling = curChild.nextSibling;\n\n                var key = getNodeKey(curChild);\n                if (key) {\n                    var unmatchedFromEl = fromNodesLookup[key];\n                    if (unmatchedFromEl && compareNodeNames(curChild, unmatchedFromEl)) {\n                        curChild.parentNode.replaceChild(unmatchedFromEl, curChild);\n                        morphChildren(unmatchedFromEl, curChild);\n                    }\n                }\n\n                handleNodeAdded(curChild);\n                curChild = nextSibling;\n            }\n        }\n\n        function morphChildren(fromEl, toEl, childrenOnly) {\n            var toElKey = getNodeKey(toEl);\n            var curFromNodeKey;\n\n            if (toElKey) {\n                // If an element with an ID is being morphed then it will be in the final\n                // DOM so clear it out of the saved elements collection\n                delete fromNodesLookup[toElKey];\n            }\n\n            if (toNode.isSameNode && toNode.isSameNode(fromNode)) {\n                return;\n            }\n\n            if (!childrenOnly) {\n                // optional\n                if (onBeforeElUpdated(fromEl, toEl) === false) {\n                    return;\n                }\n\n                // update attributes on original DOM element first\n                morphAttrs(fromEl, toEl);\n                // optional\n                onElUpdated(fromEl);\n\n                if (onBeforeElChildrenUpdated(fromEl, toEl) === false) {\n                    return;\n                }\n            }\n\n            if (fromEl.nodeName !== 'TEXTAREA') {\n                var curToNodeChild = toEl.firstChild;\n                var curFromNodeChild = fromEl.firstChild;\n                var curToNodeKey;\n\n                var fromNextSibling;\n                var toNextSibling;\n                var matchingFromEl;\n\n                // walk the children\n                outer: while (curToNodeChild) {\n                    toNextSibling = curToNodeChild.nextSibling;\n                    curToNodeKey = getNodeKey(curToNodeChild);\n\n                    // walk the fromNode children all the way through\n                    while (curFromNodeChild) {\n                        fromNextSibling = curFromNodeChild.nextSibling;\n\n                        if (curToNodeChild.isSameNode && curToNodeChild.isSameNode(curFromNodeChild)) {\n                            curToNodeChild = toNextSibling;\n                            curFromNodeChild = fromNextSibling;\n                            continue outer;\n                        }\n\n                        curFromNodeKey = getNodeKey(curFromNodeChild);\n\n                        var curFromNodeType = curFromNodeChild.nodeType;\n\n                        var isCompatible = undefined;\n\n                        if (curFromNodeType === curToNodeChild.nodeType) {\n                            if (curFromNodeType === ELEMENT_NODE) {\n                                // Both nodes being compared are Element nodes\n\n                                if (curToNodeKey) {\n                                    // The target node has a key so we want to match it up with the correct element\n                                    // in the original DOM tree\n                                    if (curToNodeKey !== curFromNodeKey) {\n                                        // The current element in the original DOM tree does not have a matching key so\n                                        // let's check our lookup to see if there is a matching element in the original\n                                        // DOM tree\n                                        if ((matchingFromEl = fromNodesLookup[curToNodeKey])) {\n                                            if (fromNextSibling === matchingFromEl) {\n                                                // Special case for single element removals. To avoid removing the original\n                                                // DOM node out of the tree (since that can break CSS transitions, etc.),\n                                                // we will instead discard the current node and wait until the next\n                                                // iteration to properly match up the keyed target element with its matching\n                                                // element in the original tree\n                                                isCompatible = false;\n                                            } else {\n                                                // We found a matching keyed element somewhere in the original DOM tree.\n                                                // Let's move the original DOM node into the current position and morph\n                                                // it.\n\n                                                // NOTE: We use insertBefore instead of replaceChild because we want to go through\n                                                // the `removeNode()` function for the node that is being discarded so that\n                                                // all lifecycle hooks are correctly invoked\n                                                fromEl.insertBefore(matchingFromEl, curFromNodeChild);\n\n                                                // fromNextSibling = curFromNodeChild.nextSibling;\n\n                                                if (curFromNodeKey) {\n                                                    // Since the node is keyed it might be matched up later so we defer\n                                                    // the actual removal to later\n                                                    addKeyedRemoval(curFromNodeKey);\n                                                } else {\n                                                    // NOTE: we skip nested keyed nodes from being removed since there is\n                                                    //       still a chance they will be matched up later\n                                                    removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n                                                }\n\n                                                curFromNodeChild = matchingFromEl;\n                                            }\n                                        } else {\n                                            // The nodes are not compatible since the \"to\" node has a key and there\n                                            // is no matching keyed node in the source tree\n                                            isCompatible = false;\n                                        }\n                                    }\n                                } else if (curFromNodeKey) {\n                                    // The original has a key\n                                    isCompatible = false;\n                                }\n\n                                isCompatible = isCompatible !== false && compareNodeNames(curFromNodeChild, curToNodeChild);\n                                if (isCompatible) {\n                                    // We found compatible DOM elements so transform\n                                    // the current \"from\" node to match the current\n                                    // target DOM node.\n                                    // MORPH\n                                    morphChildren(curFromNodeChild, curToNodeChild);\n                                }\n\n                            } else if (curFromNodeType === TEXT_NODE || curFromNodeType == COMMENT_NODE) {\n                                // Both nodes being compared are Text or Comment nodes\n                                isCompatible = true;\n                                // Simply update nodeValue on the original node to\n                                // change the text value\n                                if (curFromNodeChild.nodeValue !== curToNodeChild.nodeValue) {\n                                    curFromNodeChild.nodeValue = curToNodeChild.nodeValue;\n                                }\n\n                            }\n                        }\n\n                        if (isCompatible) {\n                            // Advance both the \"to\" child and the \"from\" child since we found a match\n                            curToNodeChild = toNextSibling;\n                            curFromNodeChild = fromNextSibling;\n                            continue outer;\n                        }\n\n                        // No compatible match so remove the old node from the DOM and continue trying to find a\n                        // match in the original DOM. However, we only do this if the from node is not keyed\n                        // since it is possible that a keyed node might match up with a node somewhere else in the\n                        // target tree and we don't want to discard it just yet since it still might find a\n                        // home in the final DOM tree. After everything is done we will remove any keyed nodes\n                        // that didn't find a home\n                        if (curFromNodeKey) {\n                            // Since the node is keyed it might be matched up later so we defer\n                            // the actual removal to later\n                            addKeyedRemoval(curFromNodeKey);\n                        } else {\n                            // NOTE: we skip nested keyed nodes from being removed since there is\n                            //       still a chance they will be matched up later\n                            removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n                        }\n\n                        curFromNodeChild = fromNextSibling;\n                    } // END: while(curFromNodeChild) {}\n\n                    // If we got this far then we did not find a candidate match for\n                    // our \"to node\" and we exhausted all of the children \"from\"\n                    // nodes. Therefore, we will just append the current \"to\" node\n                    // to the end\n                    if (curToNodeKey && (matchingFromEl = fromNodesLookup[curToNodeKey]) && compareNodeNames(matchingFromEl, curToNodeChild)) {\n                        fromEl.appendChild(matchingFromEl);\n                        // MORPH\n                        morphChildren(matchingFromEl, curToNodeChild);\n                    } else {\n                        var onBeforeNodeAddedResult = onBeforeNodeAdded(curToNodeChild);\n                        if (onBeforeNodeAddedResult !== false) {\n                            if (onBeforeNodeAddedResult) {\n                                curToNodeChild = onBeforeNodeAddedResult;\n                            }\n\n                            if (curToNodeChild.actualize) {\n                                curToNodeChild = curToNodeChild.actualize(fromEl.ownerDocument || doc);\n                            }\n                            fromEl.appendChild(curToNodeChild);\n                            handleNodeAdded(curToNodeChild);\n                        }\n                    }\n\n                    curToNodeChild = toNextSibling;\n                    curFromNodeChild = fromNextSibling;\n                }\n\n                // We have processed all of the \"to nodes\". If curFromNodeChild is\n                // non-null then we still have some from nodes left over that need\n                // to be removed\n                while (curFromNodeChild) {\n                    fromNextSibling = curFromNodeChild.nextSibling;\n                    if ((curFromNodeKey = getNodeKey(curFromNodeChild))) {\n                        // Since the node is keyed it might be matched up later so we defer\n                        // the actual removal to later\n                        addKeyedRemoval(curFromNodeKey);\n                    } else {\n                        // NOTE: we skip nested keyed nodes from being removed since there is\n                        //       still a chance they will be matched up later\n                        removeNode(curFromNodeChild, fromEl, true /* skip keyed nodes */);\n                    }\n                    curFromNodeChild = fromNextSibling;\n                }\n            }\n\n            var specialElHandler = specialElHandlers[fromEl.nodeName];\n            if (specialElHandler) {\n                specialElHandler(fromEl, toEl);\n            }\n        } // END: morphChildren(...)\n\n        var morphedNode = fromNode;\n        var morphedNodeType = morphedNode.nodeType;\n        var toNodeType = toNode.nodeType;\n\n        if (!childrenOnly) {\n            // Handle the case where we are given two DOM nodes that are not\n            // compatible (e.g. <div> --> <span> or <div> --> TEXT)\n            if (morphedNodeType === ELEMENT_NODE) {\n                if (toNodeType === ELEMENT_NODE) {\n                    if (!compareNodeNames(fromNode, toNode)) {\n                        onNodeDiscarded(fromNode);\n                        morphedNode = moveChildren(fromNode, createElementNS(toNode.nodeName, toNode.namespaceURI));\n                    }\n                } else {\n                    // Going from an element node to a text node\n                    morphedNode = toNode;\n                }\n            } else if (morphedNodeType === TEXT_NODE || morphedNodeType === COMMENT_NODE) { // Text or comment node\n                if (toNodeType === morphedNodeType) {\n                    if (morphedNode.nodeValue !== toNode.nodeValue) {\n                        morphedNode.nodeValue = toNode.nodeValue;\n                    }\n\n                    return morphedNode;\n                } else {\n                    // Text node to something else\n                    morphedNode = toNode;\n                }\n            }\n        }\n\n        if (morphedNode === toNode) {\n            // The \"to node\" was not compatible with the \"from node\" so we had to\n            // toss out the \"from node\" and use the \"to node\"\n            onNodeDiscarded(fromNode);\n        } else {\n            morphChildren(morphedNode, toNode, childrenOnly);\n\n            // We now need to loop over any keyed nodes that might need to be\n            // removed. We only do the removal if we know that the keyed node\n            // never found a match. When a keyed node is matched up we remove\n            // it out of fromNodesLookup and we use fromNodesLookup to determine\n            // if a keyed node has been matched up or not\n            if (keyedRemovalList) {\n                for (var i=0, len=keyedRemovalList.length; i<len; i++) {\n                    var elToRemove = fromNodesLookup[keyedRemovalList[i]];\n                    if (elToRemove) {\n                        removeNode(elToRemove, elToRemove.parentNode, false);\n                    }\n                }\n            }\n        }\n\n        if (!childrenOnly && morphedNode !== fromNode && fromNode.parentNode) {\n            if (morphedNode.actualize) {\n                morphedNode = morphedNode.actualize(fromNode.ownerDocument || doc);\n            }\n            // If we had to swap out the from node with a new node because the old\n            // node was not compatible with the target node then we need to\n            // replace the old DOM node in the original DOM tree. This is only\n            // possible if the original DOM node was part of a DOM tree which\n            // we know is the case if it has a parent node.\n            fromNode.parentNode.replaceChild(morphedNode, fromNode);\n        }\n\n        return morphedNode;\n    };\n}\n\nvar morphdom = morphdomFactory(morphAttrs);\n\nexport default morphdom;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/morphdom/dist/morphdom-esm.js\n// module id = 4\n// module chunks = 0"],"sourceRoot":""}